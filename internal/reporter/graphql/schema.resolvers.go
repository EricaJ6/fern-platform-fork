package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.75

import (
	"context"
	"fmt"
	"strconv"
	"strings"
	"time"

	"github.com/guidewire-oss/fern-platform/internal/reporter/graphql/generated"
	"github.com/guidewire-oss/fern-platform/internal/reporter/graphql/model"
	"github.com/guidewire-oss/fern-platform/pkg/database"
	authDomain "github.com/guidewire-oss/fern-platform/internal/domains/auth/domain"
)

// CreateTestRun is the resolver for the createTestRun field.
func (r *mutationResolver) CreateTestRun(ctx context.Context, input model.CreateTestRunInput) (*model.TestRun, error) {
	panic(fmt.Errorf("not implemented: CreateTestRun - createTestRun"))
}

// UpdateTestRunStatus is the resolver for the updateTestRunStatus field.
func (r *mutationResolver) UpdateTestRunStatus(ctx context.Context, runID string, status string, endTime *time.Time) (*model.TestRun, error) {
	panic(fmt.Errorf("not implemented: UpdateTestRunStatus - updateTestRunStatus"))
}

// DeleteTestRun is the resolver for the deleteTestRun field.
func (r *mutationResolver) DeleteTestRun(ctx context.Context, id string) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteTestRun - deleteTestRun"))
}

// AssignTagsToTestRun is the resolver for the assignTagsToTestRun field.
func (r *mutationResolver) AssignTagsToTestRun(ctx context.Context, testRunID string, tagIds []string) (*model.TestRun, error) {
	panic(fmt.Errorf("not implemented: AssignTagsToTestRun - assignTagsToTestRun"))
}

// CreateProject is the resolver for the createProject field.
func (r *mutationResolver) CreateProject(ctx context.Context, input model.CreateProjectInput) (*model.Project, error) {
	// Use domain service implementation
	return r.CreateProject_domain(ctx, input)
}

// UpdateProject is the resolver for the updateProject field.
func (r *mutationResolver) UpdateProject(ctx context.Context, id string, input model.UpdateProjectInput) (*model.Project, error) {
	// Use domain service implementation
	return r.UpdateProject_domain(ctx, id, input)
}

// DeleteProject is the resolver for the deleteProject field.
func (r *mutationResolver) DeleteProject(ctx context.Context, id string) (bool, error) {
	// Use domain service implementation
	return r.DeleteProject_domain(ctx, id)
}

// ActivateProject is the resolver for the activateProject field.
func (r *mutationResolver) ActivateProject(ctx context.Context, projectID string) (*model.Project, error) {
	panic(fmt.Errorf("not implemented: ActivateProject - activateProject"))
}

// DeactivateProject is the resolver for the deactivateProject field.
func (r *mutationResolver) DeactivateProject(ctx context.Context, projectID string) (*model.Project, error) {
	panic(fmt.Errorf("not implemented: DeactivateProject - deactivateProject"))
}

// CreateTag is the resolver for the createTag field.
func (r *mutationResolver) CreateTag(ctx context.Context, input model.CreateTagInput) (*model.Tag, error) {
	// Use domain service implementation
	return r.CreateTag_domain(ctx, input)
}

// UpdateTag is the resolver for the updateTag field.
func (r *mutationResolver) UpdateTag(ctx context.Context, id string, input model.UpdateTagInput) (*model.Tag, error) {
	panic(fmt.Errorf("not implemented: UpdateTag - updateTag"))
}

// DeleteTag is the resolver for the deleteTag field.
func (r *mutationResolver) DeleteTag(ctx context.Context, id string) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteTag - deleteTag"))
}

// MarkFlakyTestResolved is the resolver for the markFlakyTestResolved field.
func (r *mutationResolver) MarkFlakyTestResolved(ctx context.Context, id string) (*model.FlakyTest, error) {
	panic(fmt.Errorf("not implemented: MarkFlakyTestResolved - markFlakyTestResolved"))
}

// MarkSpecAsFlaky is the resolver for the markSpecAsFlaky field.
func (r *mutationResolver) MarkSpecAsFlaky(ctx context.Context, specRunID string) (*model.SpecRun, error) {
	panic(fmt.Errorf("not implemented: MarkSpecAsFlaky - markSpecAsFlaky"))
}

// CanManage is the resolver for the canManage field.
func (r *projectResolver) CanManage(ctx context.Context, obj *model.Project) (bool, error) {
	// Get current user from context
	user, err := getCurrentUser(ctx)
	if err != nil {
		return false, nil // Not authenticated, can't manage
	}

	// Admin can manage all projects
	if user.Role == authDomain.RoleAdmin {
		return true, nil
	}

	// Get role group names from context
	roleGroups := getRoleGroupNamesFromContext(ctx)

	// Check if user has team + manager group combination
	if obj.Team != nil && *obj.Team != "" {
		hasTeamGroup := false
		hasManagerGroup := false

		for _, group := range user.Groups {
			groupName := strings.TrimPrefix(group.GroupName, "/")
			if groupName == *obj.Team {
				hasTeamGroup = true
			}
			if groupName == roleGroups.ManagerGroup {
				hasManagerGroup = true
			}
		}

		// If user is in both team and manager groups, they can manage
		if hasTeamGroup && hasManagerGroup {
			return true, nil
		}
	}

	// Check scopes for management permissions
	requiredScopes := []string{
		fmt.Sprintf("project:write:%s", obj.ProjectID),
		fmt.Sprintf("project:delete:%s", obj.ProjectID),
		fmt.Sprintf("project:*:%s", obj.ProjectID),
	}

	// If project has a team, also check team-based scopes
	if obj.Team != nil && *obj.Team != "" {
		requiredScopes = append(requiredScopes,
			fmt.Sprintf("project:write:%s:*", *obj.Team),
			fmt.Sprintf("project:*:%s:*", *obj.Team),
		)
	}

	// Check if user has any of the required scopes
	userScopes := getUserScopesFromContext(ctx)
	for _, scope := range userScopes {
		for _, required := range requiredScopes {
			if matchScope(scope, required) {
				return true, nil
			}
		}
	}

	// Check explicit project permissions in database
	// TODO: Migrate to domain permission model
	type ProjectPermission struct {
		ID         uint
		ProjectID  string
		UserID     string
		Permission string
		ExpiresAt  *time.Time
	}
	var perm ProjectPermission
	now := time.Now()
	err = r.db.Where("project_id = ? AND user_id = ? AND permission IN ? AND (expires_at IS NULL OR expires_at > ?)",
		obj.ProjectID, user.UserID, []string{"write", "delete", "admin"}, now).First(&perm).Error

	return err == nil, nil
}

// Stats is the resolver for the stats field.
func (r *projectResolver) Stats(ctx context.Context, obj *model.Project) (*model.ProjectStats, error) {
	// TODO: Implement project stats in domain service
	return nil, nil
}

// CurrentUser is the resolver for the currentUser field.
func (r *queryResolver) CurrentUser(ctx context.Context) (*model.User, error) {
	user, ok := ctx.Value("user").(*authDomain.User)
	if !ok {
		return nil, fmt.Errorf("user not authenticated")
	}

	// Extract group names from Groups
	groups := make([]string, len(user.Groups))
	for i, g := range user.Groups {
		groups[i] = g.GroupName
	}

	return &model.User{
		ID:          user.UserID,
		UserID:      user.UserID,
		Email:       user.Email,
		Name:        user.Name,
		FirstName:   &user.FirstName,
		LastName:    &user.LastName,
		Role:        string(user.Role),
		ProfileURL:  convertStringPtr(user.ProfileURL),
		Groups:      groups,
		CreatedAt:   user.CreatedAt,
		LastLoginAt: user.LastLoginAt,
	}, nil
}

// SystemConfig is the resolver for the systemConfig field.
func (r *queryResolver) SystemConfig(ctx context.Context) (*model.SystemConfig, error) {
	// Get role group names from context
	roleGroups := getRoleGroupNamesFromContext(ctx)

	return &model.SystemConfig{
		RoleGroups: &model.RoleGroupConfig{
			AdminGroup:   roleGroups.AdminGroup,
			ManagerGroup: roleGroups.ManagerGroup,
			UserGroup:    roleGroups.UserGroup,
		},
	}, nil
}

// DashboardSummary is the resolver for the dashboardSummary field.
func (r *queryResolver) DashboardSummary(ctx context.Context) (*model.DashboardSummary, error) {
	// Use domain service implementation
	return r.DashboardSummary_domain(ctx)
}

// Health is the resolver for the health field.
func (r *queryResolver) Health(ctx context.Context) (*model.HealthStatus, error) {
	version := "1.0.0" // TODO: Get from build info
	return &model.HealthStatus{
		Status:    "healthy",
		Service:   "fern-platform",
		Timestamp: time.Now(),
		Version:   &version,
	}, nil
}

// TreemapData is the resolver for the treemapData field.
func (r *queryResolver) TreemapData(ctx context.Context, projectID *string, days *int) (*model.TreemapData, error) {
	// Use domain service implementation
	return r.TreemapData_domain(ctx, projectID, days)
}

// TestRun is the resolver for the testRun field.
func (r *queryResolver) TestRun(ctx context.Context, id string) (*model.TestRun, error) {
	// Use domain service implementation
	return r.GetTestRun_domain(ctx, id)
}

// TestRunByRunID is the resolver for the testRunByRunId field.
func (r *queryResolver) TestRunByRunID(ctx context.Context, runID string) (*model.TestRun, error) {
	// Use domain service implementation
	testRun, err := r.testingService.GetTestRunByRunID(ctx, runID)
	if err != nil {
		return nil, fmt.Errorf("failed to get test run: %w", err)
	}
	return r.convertTestRunToGraphQL(testRun), nil
}

// TestRuns is the resolver for the testRuns field.
func (r *queryResolver) TestRuns(ctx context.Context, filter *model.TestRunFilter, first *int, after *string, orderBy *string, orderDirection *model.OrderDirection) (*model.TestRunConnection, error) {
	// Use domain service implementation
	return r.TestRuns_domain(ctx, filter, first, after, orderBy, orderDirection)
}

// TestRunStats is the resolver for the testRunStats field.
func (r *queryResolver) TestRunStats(ctx context.Context, projectID *string, days *int) (*model.TestRunStats, error) {
	// TODO: Implement test run stats using domain service
	return &model.TestRunStats{
		TotalRuns:       0,
		StatusCounts:    []*model.StatusCount{},
		AverageDuration: 0,
		SuccessRate:     0.0,
	}, nil
}

// RecentTestRuns is the resolver for the recentTestRuns field.
func (r *queryResolver) RecentTestRuns(ctx context.Context, projectID *string, limit *int) ([]*model.TestRun, error) {
	// Use domain service implementation
	return r.RecentTestRuns_domain(ctx, projectID, limit)
}

// Project is the resolver for the project field.
func (r *queryResolver) Project(ctx context.Context, id string) (*model.Project, error) {
	// Use domain service implementation
	return r.Project_domain(ctx, id)
}

// ProjectByProjectID is the resolver for the projectByProjectId field.
func (r *queryResolver) ProjectByProjectID(ctx context.Context, projectID string) (*model.Project, error) {
	// Use domain service implementation
	return r.ProjectByProjectID_domain(ctx, projectID)
}

// Projects is the resolver for the projects field.
func (r *queryResolver) Projects(ctx context.Context, filter *model.ProjectFilter, first *int, after *string) (*model.ProjectConnection, error) {
	// Use domain service implementation
	return r.Projects_domain(ctx, filter, first, after)
}

// Tag is the resolver for the tag field.
func (r *queryResolver) Tag(ctx context.Context, id string) (*model.Tag, error) {
	panic(fmt.Errorf("not implemented: Tag - tag"))
}

// TagByName is the resolver for the tagByName field.
func (r *queryResolver) TagByName(ctx context.Context, name string) (*model.Tag, error) {
	panic(fmt.Errorf("not implemented: TagByName - tagByName"))
}

// Tags is the resolver for the tags field.
func (r *queryResolver) Tags(ctx context.Context, filter *model.TagFilter, first *int, after *string) (*model.TagConnection, error) {
	// Use domain service implementation
	return r.Tags_domain(ctx, filter, first, after)
}

// TagUsageStats is the resolver for the tagUsageStats field.
func (r *queryResolver) TagUsageStats(ctx context.Context) ([]*model.TagUsage, error) {
	panic(fmt.Errorf("not implemented: TagUsageStats - tagUsageStats"))
}

// PopularTags is the resolver for the popularTags field.
func (r *queryResolver) PopularTags(ctx context.Context, limit *int) ([]*model.TagUsage, error) {
	panic(fmt.Errorf("not implemented: PopularTags - popularTags"))
}

// FlakyTest is the resolver for the flakyTest field.
func (r *queryResolver) FlakyTest(ctx context.Context, id string) (*model.FlakyTest, error) {
	panic(fmt.Errorf("not implemented: FlakyTest - flakyTest"))
}

// FlakyTests is the resolver for the flakyTests field.
func (r *queryResolver) FlakyTests(ctx context.Context, filter *model.FlakyTestFilter, first *int, after *string, orderBy *string, orderDirection *model.OrderDirection) (*model.FlakyTestConnection, error) {
	panic(fmt.Errorf("not implemented: FlakyTests - flakyTests"))
}

// FlakyTestStats is the resolver for the flakyTestStats field.
func (r *queryResolver) FlakyTestStats(ctx context.Context, projectID *string) (*model.FlakyTestStats, error) {
	panic(fmt.Errorf("not implemented: FlakyTestStats - flakyTestStats"))
}

// RecentlyAddedFlakyTests is the resolver for the recentlyAddedFlakyTests field.
func (r *queryResolver) RecentlyAddedFlakyTests(ctx context.Context, projectID *string, days *int, limit *int) ([]*model.FlakyTest, error) {
	panic(fmt.Errorf("not implemented: RecentlyAddedFlakyTests - recentlyAddedFlakyTests"))
}

// TestRunCreated is the resolver for the testRunCreated field.
func (r *subscriptionResolver) TestRunCreated(ctx context.Context, projectID *string) (<-chan *model.TestRun, error) {
	panic(fmt.Errorf("not implemented: TestRunCreated - testRunCreated"))
}

// TestRunUpdated is the resolver for the testRunUpdated field.
func (r *subscriptionResolver) TestRunUpdated(ctx context.Context, projectID *string) (<-chan *model.TestRun, error) {
	panic(fmt.Errorf("not implemented: TestRunUpdated - testRunUpdated"))
}

// TestRunStatusChanged is the resolver for the testRunStatusChanged field.
func (r *subscriptionResolver) TestRunStatusChanged(ctx context.Context, projectID *string) (<-chan *model.TestRun, error) {
	panic(fmt.Errorf("not implemented: TestRunStatusChanged - testRunStatusChanged"))
}

// FlakyTestDetected is the resolver for the flakyTestDetected field.
func (r *subscriptionResolver) FlakyTestDetected(ctx context.Context, projectID *string) (<-chan *model.FlakyTest, error) {
	panic(fmt.Errorf("not implemented: FlakyTestDetected - flakyTestDetected"))
}

// SpecRuns is the resolver for the specRuns field.
func (r *suiteRunResolver) SpecRuns(ctx context.Context, obj *model.SuiteRun) ([]*model.SpecRun, error) {
	r.logger.WithField("suite_run_id", obj.ID).Debug("Loading spec runs for suite run")

	// Get data loader from context
	loaders := getLoaders(ctx)
	if loaders == nil {
		r.logger.Error("Data loaders not found in context")
		return nil, fmt.Errorf("data loaders not found in context")
	}

	// Load spec runs for this suite run - bypass DataLoader for now
	var specRuns []*database.SpecRun
	intID, err := strconv.Atoi(obj.ID)
	if err != nil {
		r.logger.WithError(err).WithField("suite_run_id", obj.ID).Error("Failed to parse suite run ID")
		return nil, fmt.Errorf("invalid suite run ID: %w", err)
	}

	if err := r.db.Where("suite_run_id = ?", intID).Find(&specRuns).Error; err != nil {
		r.logger.WithError(err).WithField("suite_run_id", obj.ID).Error("Failed to load spec runs directly")
		return nil, fmt.Errorf("failed to load spec runs: %w", err)
	}

	r.logger.WithFields(map[string]interface{}{
		"suite_run_id": obj.ID,
		"spec_count":   len(specRuns),
	}).Debug("Loaded spec runs")

	// Convert to GraphQL models
	result := make([]*model.SpecRun, len(specRuns))
	for i, sp := range specRuns {
		// Check for zero time values which might be interpreted as null
		startTime := sp.StartTime
		if startTime.IsZero() {
			r.logger.WithFields(map[string]interface{}{
				"spec_run_id": sp.ID,
				"spec_name":   sp.SpecName,
			}).Warn("SpecRun has zero StartTime, using current time")
			startTime = time.Now() // Use current time as fallback
		}

		result[i] = &model.SpecRun{
			ID:           fmt.Sprintf("%d", sp.ID),
			SuiteRunID:   fmt.Sprintf("%d", sp.SuiteRunID),
			SpecName:     sp.SpecName,
			Status:       sp.Status,
			StartTime:    startTime,
			EndTime:      sp.EndTime,
			Duration:     int(sp.Duration),
			ErrorMessage: convertStringPtr(sp.ErrorMessage),
			StackTrace:   convertStringPtr(sp.StackTrace),
			RetryCount:   sp.RetryCount,
			IsFlaky:      sp.IsFlaky,
			CreatedAt:    sp.CreatedAt,
			UpdatedAt:    sp.UpdatedAt,
		}
	}

	return result, nil
}

// SuiteRuns is the resolver for the suiteRuns field.
func (r *testRunResolver) SuiteRuns(ctx context.Context, obj *model.TestRun) ([]*model.SuiteRun, error) {
	r.logger.WithField("test_run_id", obj.ID).Debug("Loading suite runs for test run")

	// Get data loader from context
	loaders := getLoaders(ctx)
	if loaders == nil {
		r.logger.Error("Data loaders not found in context")
		return nil, fmt.Errorf("data loaders not found in context")
	}

	// Load suite runs for this test run
	r.logger.WithField("test_run_id", obj.ID).Debug("About to load suite runs")

	// For now, bypass DataLoader to test if that's the issue
	var suiteRuns []*database.SuiteRun
	intID, err := strconv.Atoi(obj.ID)
	if err != nil {
		r.logger.WithError(err).WithField("test_run_id", obj.ID).Error("Failed to parse test run ID")
		return nil, fmt.Errorf("invalid test run ID: %w", err)
	}

	if err := r.db.Where("test_run_id = ?", intID).Find(&suiteRuns).Error; err != nil {
		r.logger.WithError(err).WithField("test_run_id", obj.ID).Error("Failed to load suite runs directly")
		return nil, fmt.Errorf("failed to load suite runs: %w", err)
	}

	r.logger.WithFields(map[string]interface{}{
		"test_run_id": obj.ID,
		"suite_count": len(suiteRuns),
	}).Debug("Loaded suite runs directly without DataLoader")

	// Convert to GraphQL models
	result := make([]*model.SuiteRun, len(suiteRuns))
	for i, sr := range suiteRuns {
		result[i] = &model.SuiteRun{
			ID:           fmt.Sprintf("%d", sr.ID),
			TestRunID:    fmt.Sprintf("%d", sr.TestRunID),
			SuiteName:    sr.SuiteName,
			Status:       sr.Status,
			StartTime:    sr.StartTime,
			EndTime:      sr.EndTime,
			TotalSpecs:   sr.TotalSpecs,
			PassedSpecs:  sr.PassedSpecs,
			FailedSpecs:  sr.FailedSpecs,
			SkippedSpecs: sr.SkippedSpecs,
			Duration:     int(sr.Duration),
			CreatedAt:    sr.CreatedAt,
			UpdatedAt:    sr.UpdatedAt,
		}
	}

	return result, nil
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Project returns generated.ProjectResolver implementation.
func (r *Resolver) Project() generated.ProjectResolver { return &projectResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

// Subscription returns generated.SubscriptionResolver implementation.
func (r *Resolver) Subscription() generated.SubscriptionResolver { return &subscriptionResolver{r} }

// SuiteRun returns generated.SuiteRunResolver implementation.
func (r *Resolver) SuiteRun() generated.SuiteRunResolver { return &suiteRunResolver{r} }

// TestRun returns generated.TestRunResolver implementation.
func (r *Resolver) TestRun() generated.TestRunResolver { return &testRunResolver{r} }

type mutationResolver struct{ *Resolver }
type projectResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
type suiteRunResolver struct{ *Resolver }
type testRunResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//  - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//    it when you're done.
//  - You have helper methods in this file. Move them out to keep these resolver files clean.
/*
	func (r *tagUsageResolver) ID(ctx context.Context, obj interface{}) (string, error) {
	panic(fmt.Errorf("not implemented: ID - id"))
}
func (r *Resolver) TagUsage() generated.TagUsageResolver { return &tagUsageResolver{r} }
type tagUsageResolver struct{ *Resolver }
*/
